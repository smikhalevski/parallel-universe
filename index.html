<!DOCTYPE html><html class="default"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>parallel-universe - v1.1.2</title><meta name="description" content="Documentation for parallel-universe - v1.1.2"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script async src="assets/search.js" id="search-script"></script></head><body><script>document.body.classList.add(localStorage.getItem("tsd-theme") || "os")</script><header><div class="tsd-page-toolbar"><div class="container"><div class="table-wrap"><div class="table-cell" id="tsd-search" data-base="."><div class="field"><label for="tsd-search-field" class="tsd-widget search no-caption">Search</label><input type="text" id="tsd-search-field"/></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">parallel-universe - v1.1.2</a></div><div class="table-cell" id="tsd-widgets"><div id="tsd-filter"><a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a><div class="tsd-filter-group"><div class="tsd-select" id="tsd-filter-visibility"><span class="tsd-select-label">All</span><ul class="tsd-select-list"><li data-value="public">Public</li><li data-value="protected">Public/Protected</li><li data-value="private" class="selected">All</li></ul></div> <input type="checkbox" id="tsd-filter-inherited" checked/><label class="tsd-widget" for="tsd-filter-inherited">Inherited</label><input type="checkbox" id="tsd-filter-externals" checked/><label class="tsd-widget" for="tsd-filter-externals">Externals</label></div></div><a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a></div></div></div></div><div class="tsd-page-title"><div class="container"><h1>parallel-universe - v1.1.2</h1></div></div></header><div class="container container-main"><div class="row"><div class="col-8 col-content"><div class="tsd-panel tsd-typography">
<a href="#parallel-universe-" id="parallel-universe-" style="color: inherit; text-decoration: none;">
  <h1>parallel-universe <a href="https://github.com/smikhalevski/parallel-universe/actions/workflows/master.yml"><img src="https://github.com/smikhalevski/parallel-universe/actions/workflows/master.yml/badge.svg?branch=master&event=push" alt="build"></a></h1>
</a>
<a href="#readme">
  <img alt="Spaceman" src="https://github.com/smikhalevski/parallel-universe/raw/master/spaceman.png"/>
</a>

<p>The set of async flow control structures and promise utils.</p>
<pre><code class="language-sh"><span class="hl-0">npm install --save-prod parallel-universe</span>
</code></pre>
<p>ðŸš€ <a href="https://smikhalevski.github.io/parallel-universe/">API documentation is available here.</a></p>
<ul>
<li><a href="#asyncqueue"><code>AsyncQueue</code></a></li>
<li><a href="#workpool"><code>WorkPool</code></a></li>
<li><a href="#executor"><code>Executor</code></a></li>
<li><a href="#lock"><code>Lock</code></a></li>
<li><a href="#blocker"><code>Blocker</code></a></li>
<li><a href="#untiltruthy"><code>untilTruthy</code></a></li>
<li><a href="#repeatuntil"><code>repeatUntil</code></a></li>
<li><a href="#sleep"><code>sleep</code></a></li>
<li><a href="#timeout"><code>timeout</code></a></li>
</ul>

<a href="#asyncqueue" id="asyncqueue" style="color: inherit; text-decoration: none;">
  <h1><code>AsyncQueue</code></h1>
</a>
<p>Asynchronous queue decouples value providers and value consumers.</p>
<pre><code class="language-ts"><span class="hl-1">const</span><span class="hl-0"> </span><span class="hl-2">queue</span><span class="hl-0"> = </span><span class="hl-1">new</span><span class="hl-0"> </span><span class="hl-3">AsyncQueue</span><span class="hl-0">();</span><br/><br/><span class="hl-4">// Provider adds a value</span><br/><span class="hl-5">queue</span><span class="hl-0">.</span><span class="hl-3">add</span><span class="hl-0">(</span><span class="hl-6">&#39;Mars&#39;</span><span class="hl-0">);</span><br/><br/><span class="hl-4">// Consumer takes a value</span><br/><span class="hl-5">queue</span><span class="hl-0">.</span><span class="hl-3">take</span><span class="hl-0">(); </span><span class="hl-4">// â†’ Promise&lt;&quot;Mars&quot;&gt;</span>
</code></pre>
<p><code>add</code> appends the value to the queue, while <code>take</code> removes the value from the queue as soon as it is available. If there
are no values in the queue upon <code>take</code> call then the returned promise is resolved after the next <code>add</code> call.</p>
<pre><code class="language-ts"><span class="hl-1">const</span><span class="hl-0"> </span><span class="hl-2">queue</span><span class="hl-0"> = </span><span class="hl-1">new</span><span class="hl-0"> </span><span class="hl-3">AsyncQueue</span><span class="hl-0">();</span><br/><br/><span class="hl-4">// The returned Promise would be resolved after the add call</span><br/><span class="hl-5">queue</span><span class="hl-0">.</span><span class="hl-3">take</span><span class="hl-0">(); </span><span class="hl-4">// â†’ Promise&lt;&quot;Mars&quot;&gt;</span><br/><br/><span class="hl-5">queue</span><span class="hl-0">.</span><span class="hl-3">add</span><span class="hl-0">(</span><span class="hl-6">&quot;Mars&quot;</span><span class="hl-0">);</span>
</code></pre>
<p>Consumers receive values from the queue in the same order they were added by providers:</p>
<pre><code class="language-ts"><span class="hl-1">const</span><span class="hl-0"> </span><span class="hl-2">queue</span><span class="hl-0"> = </span><span class="hl-1">new</span><span class="hl-0"> </span><span class="hl-3">AsyncQueue</span><span class="hl-0">();</span><br/><br/><span class="hl-5">queue</span><span class="hl-0">.</span><span class="hl-3">add</span><span class="hl-0">(</span><span class="hl-6">&#39;Mars&#39;</span><span class="hl-0">);</span><br/><span class="hl-5">queue</span><span class="hl-0">.</span><span class="hl-3">add</span><span class="hl-0">(</span><span class="hl-6">&#39;Venus&#39;</span><span class="hl-0">);</span><br/><br/><span class="hl-5">queue</span><span class="hl-0">.</span><span class="hl-3">take</span><span class="hl-0">(); </span><span class="hl-4">// â†’ Promise&lt;&quot;Mars&quot;&gt;</span><br/><span class="hl-5">queue</span><span class="hl-0">.</span><span class="hl-3">take</span><span class="hl-0">(); </span><span class="hl-4">// â†’ Promise&lt;&quot;Venus&quot;&gt;</span>
</code></pre>

<a href="#acknowledgements" id="acknowledgements" style="color: inherit; text-decoration: none;">
  <h2>Acknowledgements</h2>
</a>
<p>In some cases removing the value from the queue isn&#39;t the desirable behavior, since the consumer may not be able to
process the taken value. Use <code>takeAck</code> to examine available value and acknowledge that it can be processed.</p>
<pre><code class="language-ts"><span class="hl-5">queue</span><span class="hl-0">.</span><span class="hl-3">takeAck</span><span class="hl-0">().</span><span class="hl-3">then</span><span class="hl-0">(([</span><span class="hl-5">value</span><span class="hl-0">, </span><span class="hl-5">ack</span><span class="hl-0">]) </span><span class="hl-1">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">  </span><span class="hl-7">if</span><span class="hl-0"> (</span><span class="hl-3">doSomeChecks</span><span class="hl-0">()) {</span><br/><span class="hl-0">    </span><span class="hl-3">ack</span><span class="hl-0">();</span><br/><span class="hl-0">    </span><span class="hl-3">doSomething</span><span class="hl-0">(</span><span class="hl-5">value</span><span class="hl-0">);</span><br/><span class="hl-0">  }</span><br/><span class="hl-0">});</span>
</code></pre>
<p><code>takeAck</code> returns a tuple of the available value and the acknowledgement callback. The consumer should call <code>ack</code> to
notify the queue on weather to remove the value from the queue or to retain it.</p>
<p>To acknowledge that the consumer can process the value, and the value must be removed from the queue use:</p>
<pre><code class="language-ts"><span class="hl-3">ack</span><span class="hl-0">(); </span><span class="hl-4">// or ack(true)</span>
</code></pre>
<p>To acknowledge that the value should be retained by the queue use:</p>
<pre><code class="language-ts"><span class="hl-3">ack</span><span class="hl-0">(</span><span class="hl-1">false</span><span class="hl-0">);</span>
</code></pre>
<p>The value that was retained in the queue becomes available for the subsequent consumer.</p>
<pre><code class="language-ts"><span class="hl-1">const</span><span class="hl-0"> </span><span class="hl-2">queue</span><span class="hl-0"> = </span><span class="hl-1">new</span><span class="hl-0"> </span><span class="hl-3">AsyncQueue</span><span class="hl-0">();</span><br/><br/><span class="hl-5">queue</span><span class="hl-0">.</span><span class="hl-3">add</span><span class="hl-0">(</span><span class="hl-6">&#39;Pluto&#39;</span><span class="hl-0">);</span><br/><br/><span class="hl-5">queue</span><span class="hl-0">.</span><span class="hl-3">takeAck</span><span class="hl-0">(([</span><span class="hl-5">value</span><span class="hl-0">, </span><span class="hl-5">ack</span><span class="hl-0">]) </span><span class="hl-1">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">  </span><span class="hl-3">ack</span><span class="hl-0">(</span><span class="hl-1">false</span><span class="hl-0">); </span><span class="hl-4">// Tells queue to retain the value</span><br/><span class="hl-0">});</span><br/><br/><span class="hl-5">queue</span><span class="hl-0">.</span><span class="hl-3">take</span><span class="hl-0">(); </span><span class="hl-4">// â†’ Promise&lt;&quot;Pluto&quot;&gt;</span>
</code></pre>

<a href="#blocking-vs-non-blocking-acknowledgements" id="blocking-vs-non-blocking-acknowledgements" style="color: inherit; text-decoration: none;">
  <h2>Blocking vs non-blocking acknowledgements</h2>
</a>
<p>By default, if you didn&#39;t call <code>ack</code>, the acknowledgement would be automatically revoked on <em>the next tick</em> after
the promise returned by <code>takeAck</code> is resolved, and the value would remain in the queue.</p>
<p>If acknowledgement was revoked, the <code>ack</code> call would throw an error:</p>
<pre><code class="language-ts"><span class="hl-5">queue</span><span class="hl-0">.</span><span class="hl-3">takeAck</span><span class="hl-0">()</span><br/><span class="hl-0">  .</span><span class="hl-3">then</span><span class="hl-0">(</span><span class="hl-5">protocol</span><span class="hl-0"> </span><span class="hl-1">=&gt;</span><span class="hl-0"> </span><span class="hl-5">protocol</span><span class="hl-0">) </span><span class="hl-4">// Extra tick</span><br/><span class="hl-0">  .</span><span class="hl-3">then</span><span class="hl-0">(([</span><span class="hl-5">value</span><span class="hl-0">, </span><span class="hl-5">ack</span><span class="hl-0">]) </span><span class="hl-1">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-3">ack</span><span class="hl-0">(); </span><span class="hl-4">// Throws an error</span><br/><span class="hl-0">  });</span>
</code></pre>
<p>To prevent the acknowledgement from being revoked, request a blocking acknowledgement:</p>
<pre><code class="language-ts"><span class="hl-5">queue</span><span class="hl-0">.</span><span class="hl-3">takeAck</span><span class="hl-0">(</span><span class="hl-1">true</span><span class="hl-0">) </span><span class="hl-4">// Request a blocking ack</span><br/><span class="hl-0">  .</span><span class="hl-3">then</span><span class="hl-0">(</span><span class="hl-5">protocol</span><span class="hl-0"> </span><span class="hl-1">=&gt;</span><span class="hl-0"> </span><span class="hl-5">protocol</span><span class="hl-0">) </span><span class="hl-4">// Extra tick</span><br/><span class="hl-0">  .</span><span class="hl-3">then</span><span class="hl-0">(([</span><span class="hl-5">value</span><span class="hl-0">, </span><span class="hl-5">ack</span><span class="hl-0">]) </span><span class="hl-1">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-3">ack</span><span class="hl-0">(); </span><span class="hl-4">// Value acknowledged</span><br/><span class="hl-0">    </span><span class="hl-3">doSomething</span><span class="hl-0">(</span><span class="hl-5">value</span><span class="hl-0">);</span><br/><span class="hl-0">  });</span>
</code></pre>
<p>Blocking acknowledgement is required if the consumer has to perform asynchronous actions before processing the value.</p>
<p>To guarantee that consumers receive values in the same order as they were provided, blocking acknowledgements prevent
subsequent consumers from being resolved until <code>ack</code> is called. Be sure to call <code>ack</code> to prevent the queue from being
stuck indefinitely.</p>
<pre><code class="language-ts"><span class="hl-1">async</span><span class="hl-0"> </span><span class="hl-1">function</span><span class="hl-0"> </span><span class="hl-3">blockingConsumer</span><span class="hl-0">() {</span><br/><span class="hl-0">  </span><span class="hl-1">const</span><span class="hl-0"> [</span><span class="hl-2">value</span><span class="hl-0">, </span><span class="hl-2">ack</span><span class="hl-0">] = </span><span class="hl-5">queue</span><span class="hl-0">.</span><span class="hl-3">takeAck</span><span class="hl-0">(</span><span class="hl-1">true</span><span class="hl-0">);</span><br/><br/><span class="hl-0">  </span><span class="hl-7">try</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-7">if</span><span class="hl-0"> (</span><span class="hl-7">await</span><span class="hl-0"> </span><span class="hl-3">doSomeChecks</span><span class="hl-0">()) {</span><br/><span class="hl-0">      </span><span class="hl-3">ack</span><span class="hl-0">(</span><span class="hl-1">true</span><span class="hl-0">);</span><br/><span class="hl-0">      </span><span class="hl-3">doSomething</span><span class="hl-0">(</span><span class="hl-5">value</span><span class="hl-0">);</span><br/><span class="hl-0">    }</span><br/><span class="hl-0">  } </span><span class="hl-7">finally</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-4">// It&#39;s safe to call ack multiple times since it&#39;s a no-op</span><br/><span class="hl-0">    </span><span class="hl-3">ack</span><span class="hl-0">(</span><span class="hl-1">false</span><span class="hl-0">);</span><br/><span class="hl-0">  }</span><br/><span class="hl-0">}</span>
</code></pre>

<a href="#workpool" id="workpool" style="color: inherit; text-decoration: none;">
  <h1><code>WorkPool</code></h1>
</a>
<p>The callback execution pool that executes the limited number of callbacks in parallel while other submitted callbacks
wait in the queue.</p>
<pre><code class="language-ts"><span class="hl-4">// The pool that processes 5 callbacks in parallel at maximum</span><br/><span class="hl-1">const</span><span class="hl-0"> </span><span class="hl-2">pool</span><span class="hl-0"> = </span><span class="hl-1">new</span><span class="hl-0"> </span><span class="hl-3">WorkPool</span><span class="hl-0">(</span><span class="hl-8">5</span><span class="hl-0">);</span><br/><br/><span class="hl-5">pool</span><span class="hl-0">.</span><span class="hl-3">submit</span><span class="hl-0">(</span><span class="hl-1">async</span><span class="hl-0"> </span><span class="hl-5">signal</span><span class="hl-0"> </span><span class="hl-1">=&gt;</span><span class="hl-0"> </span><span class="hl-3">doSomething</span><span class="hl-0">());</span><br/><span class="hl-4">// â†’ Promise&lt;ReturnType&lt;typeof doSomething&gt;&gt;</span>
</code></pre>
<p>You can change how many callbacks can the pool process in parallel:</p>
<pre><code class="language-ts"><span class="hl-5">pool</span><span class="hl-0">.</span><span class="hl-3">resize</span><span class="hl-0">(</span><span class="hl-8">2</span><span class="hl-0">); </span><span class="hl-4">// â†’ Promise&lt;void&gt;</span>
</code></pre>
<p><code>resize</code> returns the promise that is resolved when there are no excessive callbacks being processed in parallel.</p>
<p>If you resize the pool down, callbacks that are pending and exceed the new size limit, are notified via <code>signal</code> that
they must be aborted.</p>
<p>To abort all callbacks that are being processed by the pool and wait for their completion use:</p>
<pre><code class="language-ts"><span class="hl-4">// Resolved when all pending callbacks are fulfilled</span><br/><span class="hl-5">pool</span><span class="hl-0">.</span><span class="hl-3">resize</span><span class="hl-0">(</span><span class="hl-8">0</span><span class="hl-0">); </span><span class="hl-4">// â†’ Promise&lt;void&gt;</span>
</code></pre>

<a href="#executor" id="executor" style="color: inherit; text-decoration: none;">
  <h1><code>Executor</code></h1>
</a>
<p>Manages async callback execution process and provides ways to access execution results, abort or replace an execution,
and subscribe to state changes.</p>
<p>Create an <code>Executor</code> instance and submit a callback for execution:</p>
<pre><code class="language-ts"><span class="hl-1">const</span><span class="hl-0"> </span><span class="hl-2">executor</span><span class="hl-0"> = </span><span class="hl-1">new</span><span class="hl-0"> </span><span class="hl-3">Executor</span><span class="hl-0">();</span><br/><br/><span class="hl-5">executor</span><span class="hl-0">.</span><span class="hl-3">execute</span><span class="hl-0">(</span><span class="hl-5">doSomething</span><span class="hl-0">);</span><br/><span class="hl-4">// â†’ Promise&lt;void&gt; | void</span>
</code></pre>
<p>The <code>execute</code> method returns a promise if a passed callback is returns a promise, or <code>undefined</code> otherwise. The returned
promise is fulfilled when the promise returned from the callback is settled.</p>
<p>If there&#39;s a pending execution, it is aborted and the new execution is started.</p>
<p>To check that executor is currently executing a callback check
<a href="https://smikhalevski.github.io/parallel-universe/classes/Executor.html#pending"><code>pending</code></a>.</p>
<p>After a promise returned from the executed callback is settled, the execution result (or rejection reason) are available
through <a href="https://smikhalevski.github.io/parallel-universe/classes/Executor.html#result"><code>result</code></a> and
<a href="https://smikhalevski.github.io/parallel-universe/classes/Executor.html#reason"><code>reason</code></a>.</p>
<p>You can check whether the promise was
<a href="https://smikhalevski.github.io/parallel-universe/classes/Executor.html#fulfilled"><code>fulfilled</code></a>,
<a href="https://smikhalevski.github.io/parallel-universe/classes/Executor.html#rejected"><code>rejected</code></a> or
<a href="https://smikhalevski.github.io/parallel-universe/classes/Executor.html#settled"><code>settled</code></a>.</p>
<p>To abort the pending execution, you can use
an <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal">abort signal</a>
passed to the executed callback:</p>
<pre><code class="language-ts"><span class="hl-5">executor</span><span class="hl-0">.</span><span class="hl-3">execute</span><span class="hl-0">(</span><span class="hl-1">async</span><span class="hl-0"> </span><span class="hl-5">signal</span><span class="hl-0"> </span><span class="hl-1">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">  </span><span class="hl-4">// Check signal.aborted</span><br/><span class="hl-0">});</span><br/><br/><span class="hl-5">executor</span><span class="hl-0">.</span><span class="hl-3">abort</span><span class="hl-0">();</span>
</code></pre>
<p>When execution is aborted the current <code>result</code> and <code>reason</code> remain intact.</p>
<p>To reset the executor to the initial state use:</p>
<pre><code class="language-ts"><span class="hl-5">executor</span><span class="hl-0">.</span><span class="hl-3">clear</span><span class="hl-0">();</span>
</code></pre>
<p>You can directly fulfill or reject an executor:</p>
<pre><code class="language-ts"><span class="hl-5">executor</span><span class="hl-0">.</span><span class="hl-3">resolve</span><span class="hl-0">(</span><span class="hl-5">value</span><span class="hl-0">);</span><br/><br/><span class="hl-5">executor</span><span class="hl-0">.</span><span class="hl-3">reject</span><span class="hl-0">(</span><span class="hl-5">reason</span><span class="hl-0">);</span>
</code></pre>
<p>Subscribe to an executor to receive notifications when its state changes:</p>
<pre><code class="language-ts"><span class="hl-1">const</span><span class="hl-0"> </span><span class="hl-2">unsubscribe</span><span class="hl-0"> = </span><span class="hl-5">executor</span><span class="hl-0">.</span><span class="hl-3">subscribe</span><span class="hl-0">(() </span><span class="hl-1">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">  </span><span class="hl-4">// Handle the update</span><br/><span class="hl-0">});</span><br/><br/><span class="hl-3">unsubscribe</span><span class="hl-0">();</span>
</code></pre>

<a href="#lock" id="lock" style="color: inherit; text-decoration: none;">
  <h1><code>Lock</code></h1>
</a>
<p>Promise-based <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">lock implementation</a>.</p>
<p>When someone tries to acquire a <code>Lock</code> they receive a promise for a release callback that is resolved as soon as
previous lock owner invokes their release callback.</p>
<pre><code class="language-ts"><span class="hl-1">const</span><span class="hl-0"> </span><span class="hl-2">lock</span><span class="hl-0"> = </span><span class="hl-1">new</span><span class="hl-0"> </span><span class="hl-3">Lock</span><span class="hl-0">();</span><br/><br/><span class="hl-5">lock</span><span class="hl-0">.</span><span class="hl-3">acquire</span><span class="hl-0">();</span><br/><span class="hl-4">// â†’ Promise&lt;() =&gt; void&gt;</span>
</code></pre>
<p>You can check that the lock is <a href="https://smikhalevski.github.io/parallel-universe/classes/Lock.html#locked"><code>locked</code></a>
before acquiring a lock.</p>
<p>For example, if you want to force an async callback executions to be sequential you can use ane external lock:</p>
<pre><code class="language-ts"><span class="hl-1">const</span><span class="hl-0"> </span><span class="hl-2">lock</span><span class="hl-0"> = </span><span class="hl-1">new</span><span class="hl-0"> </span><span class="hl-3">Lock</span><span class="hl-0">();</span><br/><br/><span class="hl-1">async</span><span class="hl-0"> </span><span class="hl-1">function</span><span class="hl-0"> </span><span class="hl-3">doSomething</span><span class="hl-0">() {</span><br/><span class="hl-0">  </span><span class="hl-1">const</span><span class="hl-0"> </span><span class="hl-2">release</span><span class="hl-0"> = </span><span class="hl-7">await</span><span class="hl-0"> </span><span class="hl-5">lock</span><span class="hl-0">.</span><span class="hl-3">acquire</span><span class="hl-0">();</span><br/><span class="hl-0">  </span><span class="hl-7">try</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-4">// Long process is handled here</span><br/><span class="hl-0">  } </span><span class="hl-7">finally</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-3">release</span><span class="hl-0">();</span><br/><span class="hl-0">  }</span><br/><span class="hl-0">}</span><br/><br/><span class="hl-4">// Long process would be executed three times sequentially</span><br/><span class="hl-3">doSomething</span><span class="hl-0">();</span><br/><span class="hl-3">doSomething</span><span class="hl-0">();</span><br/><span class="hl-3">doSomething</span><span class="hl-0">();</span>
</code></pre>

<a href="#blocker" id="blocker" style="color: inherit; text-decoration: none;">
  <h1><code>Blocker</code></h1>
</a>
<p>Provides a mechanism for blocking an async process and unblocking it from the outside.</p>
<pre><code class="language-ts"><span class="hl-1">const</span><span class="hl-0"> </span><span class="hl-2">blocker</span><span class="hl-0"> = </span><span class="hl-1">new</span><span class="hl-0"> </span><span class="hl-3">Blocker</span><span class="hl-0">&lt;</span><span class="hl-9">string</span><span class="hl-0">&gt;();</span><br/><br/><span class="hl-5">blocker</span><span class="hl-0">.</span><span class="hl-3">block</span><span class="hl-0">();</span><br/><span class="hl-4">// â†’ Promise&lt;string&gt;</span>
</code></pre>
<p>You can later unblock it passing a value that would fulfill the promise returned from the <code>block</code> call:</p>
<pre><code class="language-ts"><span class="hl-5">blocker</span><span class="hl-0">.</span><span class="hl-3">unblock</span><span class="hl-0">(</span><span class="hl-6">&#39;Mars&#39;</span><span class="hl-0">);</span>
</code></pre>

<a href="#untiltruthy" id="untiltruthy" style="color: inherit; text-decoration: none;">
  <h1><code>untilTruthy</code></h1>
</a>
<p>Returns a promise that is fulfilled when a callback returns a truthy value, or a promise that is fulfilled with a
truthy value.</p>
<pre><code class="language-ts"><span class="hl-3">untilTruthy</span><span class="hl-0">(</span><span class="hl-5">doSomeChecks</span><span class="hl-0">);</span><br/><span class="hl-4">// â†’ Promise&lt;ReturnType&lt;typeof doSomeChecks&gt;&gt;</span>
</code></pre>
<p>If you don&#39;t want <code>untilTruthy</code> to invoke the callback too frequently, provide a delay in milliseconds:</p>
<pre><code class="language-ts"><span class="hl-3">untilTruthy</span><span class="hl-0">(</span><span class="hl-5">doSomeChecks</span><span class="hl-0">, </span><span class="hl-8">1_000</span><span class="hl-0">);</span>
</code></pre>
<p>Instead of a fixed delay you can pass a function that returns a delay:</p>
<pre><code class="language-ts"><span class="hl-3">untilTruthy</span><span class="hl-0">(</span><br/><span class="hl-0">  </span><span class="hl-5">doSomeChecks</span><span class="hl-0">,</span><br/><span class="hl-0">  </span><span class="hl-5">asyncResult</span><span class="hl-0"> </span><span class="hl-1">=&gt;</span><span class="hl-0"> </span><span class="hl-5">asyncResult</span><span class="hl-0">.</span><span class="hl-5">rejected</span><span class="hl-0"> ? </span><span class="hl-8">1_000</span><span class="hl-0"> : </span><span class="hl-8">0</span><br/><span class="hl-0">);</span>
</code></pre>
<p>If a callback starts an async process, you can use an
<a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal">abort signal</a> to abort it later:</p>
<pre><code class="language-ts"><span class="hl-1">const</span><span class="hl-0"> </span><span class="hl-2">abortController</span><span class="hl-0"> = </span><span class="hl-1">new</span><span class="hl-0"> </span><span class="hl-3">AbortController</span><span class="hl-0">();</span><br/><br/><span class="hl-3">untilTruthy</span><span class="hl-0">(</span><span class="hl-5">signal</span><span class="hl-0"> </span><span class="hl-1">=&gt;</span><span class="hl-0"> </span><span class="hl-3">doSomeChecks</span><span class="hl-0">(</span><span class="hl-5">signal</span><span class="hl-0">), </span><span class="hl-8">0</span><span class="hl-0">, </span><span class="hl-5">abortController</span><span class="hl-0">.</span><span class="hl-5">signal</span><span class="hl-0">);</span><br/><br/><span class="hl-5">abortController</span><span class="hl-0">.</span><span class="hl-3">abort</span><span class="hl-0">();</span>
</code></pre>
<p>You can combine <code>untilTruthy</code> with <a href="#timeout"><code>timeout</code></a>. For example, to poll a callback every 100 milliseconds until
it returns a truthy value or abort after 5 seconds:</p>
<pre><code class="language-ts"><span class="hl-3">timeout</span><span class="hl-0">(</span><span class="hl-3">untilTruthy</span><span class="hl-0">(</span><span class="hl-5">doSomeChecks</span><span class="hl-0">, </span><span class="hl-8">100</span><span class="hl-0">), </span><span class="hl-8">5_000</span><span class="hl-0">);</span>
</code></pre>

<a href="#repeatuntil" id="repeatuntil" style="color: inherit; text-decoration: none;">
  <h1><code>repeatUntil</code></h1>
</a>
<p>Much like a <a href="#untiltruthy"><code>untilTruthy</code></a> and provides more control when the callback polling is fulfilled.</p>
<pre><code class="language-ts"><span class="hl-3">repeatUntil</span><span class="hl-0">(</span><br/><span class="hl-0">  </span><span class="hl-4">// The callback that is invoked repeatedly</span><br/><span class="hl-0">  </span><span class="hl-1">async</span><span class="hl-0"> </span><span class="hl-5">signal</span><span class="hl-0"> </span><span class="hl-1">=&gt;</span><span class="hl-0"> </span><span class="hl-3">doSomething</span><span class="hl-0">(</span><span class="hl-5">signal</span><span class="hl-0">),</span><br/><br/><span class="hl-0">  </span><span class="hl-4">// The until clause must return true to stop the loop</span><br/><span class="hl-0">  </span><span class="hl-5">asyncResult</span><span class="hl-0"> </span><span class="hl-1">=&gt;</span><span class="hl-0"> </span><span class="hl-5">asyncResult</span><span class="hl-0">.</span><span class="hl-5">rejected</span><span class="hl-0">,</span><br/><br/><span class="hl-0">  </span><span class="hl-4">// Optional delay between callback invokations</span><br/><span class="hl-0">  </span><span class="hl-5">asyncResult</span><span class="hl-0"> </span><span class="hl-1">=&gt;</span><span class="hl-0"> </span><span class="hl-8">100</span><span class="hl-0">,</span><br/><span class="hl-0">  </span><span class="hl-4">// or just pass a literal number of milliseconds</span><br/><br/><span class="hl-0">  </span><span class="hl-4">// Optional signal that can abort the loop from the outside</span><br/><span class="hl-0">  </span><span class="hl-5">abortController</span><span class="hl-0">.</span><span class="hl-5">signal</span><span class="hl-0">,</span><br/><span class="hl-0">);</span><br/><span class="hl-4">// â†’ Promise&lt;ReturnType&lt;typeof doSomething&gt;&gt;</span>
</code></pre>

<a href="#sleep" id="sleep" style="color: inherit; text-decoration: none;">
  <h1><code>sleep</code></h1>
</a>
<p>Returns a promise that resolves after a timeout. If aborted via a passed signal then rejected with
an <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMException#aborterror"><code>AbortError</code></a>.</p>
<pre><code class="language-ts"><span class="hl-3">sleep</span><span class="hl-0">(</span><span class="hl-8">100</span><span class="hl-0">, </span><span class="hl-5">abortController</span><span class="hl-0">.</span><span class="hl-5">signal</span><span class="hl-0">);</span><br/><span class="hl-4">// â†’ Promise&lt;undefined&gt;</span>
</code></pre>

<a href="#timeout" id="timeout" style="color: inherit; text-decoration: none;">
  <h1><code>timeout</code></h1>
</a>
<p>Rejects with a <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMException#timeouterror"><code>TimeoutError</code></a> if execution
time exceeds the timeout. If aborted via a passed signal then rejected with an
<a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMException#aborterror"><code>AbortError</code></a>.</p>
<pre><code class="language-ts"><span class="hl-3">timeout</span><span class="hl-0">(</span><br/><span class="hl-0">  </span><span class="hl-1">async</span><span class="hl-0"> (</span><span class="hl-5">signal</span><span class="hl-0">) </span><span class="hl-1">=&gt;</span><span class="hl-0"> </span><span class="hl-3">doSomething</span><span class="hl-0">(),</span><br/><br/><span class="hl-0">  </span><span class="hl-4">// Execution timeout</span><br/><span class="hl-0">  </span><span class="hl-8">100</span><span class="hl-0">,</span><br/><br/><span class="hl-0">  </span><span class="hl-4">// Optional signal that can abort the execution from the outside</span><br/><span class="hl-0">  </span><span class="hl-5">abortController</span><span class="hl-0">.</span><span class="hl-5">signal</span><span class="hl-0">,</span><br/><span class="hl-0">);</span><br/><span class="hl-4">// â†’ Promise&lt;ReturnType&lt;typeof doSomething&gt;&gt;</span>
</code></pre>
</div></div><div class="col-4 col-menu menu-sticky-wrap menu-highlight"><nav class="tsd-navigation primary"><ul><li class="current"><a href="modules.html">Exports</a></li></ul></nav><nav class="tsd-navigation secondary menu-sticky"><ul><li class="tsd-kind-class tsd-has-type-parameter"><a href="classes/AsyncQueue.html" class="tsd-kind-icon">Async<wbr/>Queue</a></li><li class="tsd-kind-class tsd-has-type-parameter"><a href="classes/Blocker.html" class="tsd-kind-icon">Blocker</a></li><li class="tsd-kind-class tsd-has-type-parameter"><a href="classes/Executor.html" class="tsd-kind-icon">Executor</a></li><li class="tsd-kind-class"><a href="classes/Lock.html" class="tsd-kind-icon">Lock</a></li><li class="tsd-kind-class"><a href="classes/WorkPool.html" class="tsd-kind-icon">Work<wbr/>Pool</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/AsyncResult.html" class="tsd-kind-icon">Async<wbr/>Result</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/Execution.html" class="tsd-kind-icon">Execution</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#AckProtocol" class="tsd-kind-icon">Ack<wbr/>Protocol</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#Awaitable" class="tsd-kind-icon">Awaitable</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#ExecutorCallback" class="tsd-kind-icon">Executor<wbr/>Callback</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#isPromiseLike" class="tsd-kind-icon">is<wbr/>Promise<wbr/>Like</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#repeatUntil" class="tsd-kind-icon">repeat<wbr/>Until</a></li><li class="tsd-kind-function"><a href="modules.html#sleep" class="tsd-kind-icon">sleep</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#timeout" class="tsd-kind-icon">timeout</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#untilTruthy" class="tsd-kind-icon">until<wbr/>Truthy</a></li></ul></nav></div></div></div><footer class="with-border-bottom"><div class="container"><h2>Legend</h2><div class="tsd-legend-group"><ul class="tsd-legend"><li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li><li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li><li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li></ul><ul class="tsd-legend"><li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li><li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li></ul></div><h2>Settings</h2><p>Theme <select id="theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></p></div></footer><div class="container tsd-generator"><p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></div><div class="overlay"></div><script src="assets/main.js"></script></body></html>